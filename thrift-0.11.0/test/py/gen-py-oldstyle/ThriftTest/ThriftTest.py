#
# Autogenerated by Thrift Compiler (0.11.0)
#
# DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
#
#  options string: py:old_style
#

from thrift.Thrift import TType, TMessageType, TFrozenDict, TException, TApplicationException
from thrift.protocol.TProtocol import TProtocolException
from thrift.TRecursive import fix_spec

import sys
import logging
from .ttypes import *
from thrift.Thrift import TProcessor
from thrift.transport import TTransport
all_structs = []


class Iface:
    def testVoid(self):
        """
        Prints "testVoid()" and returns nothing.
        """
        pass

    def testString(self, thing):
        """
        Prints 'testString("%s")' with thing as '%s'
        @param string thing - the string to print
        @return string - returns the string 'thing'

        Parameters:
         - thing
        """
        pass

    def testBool(self, thing):
        """
        Prints 'testBool("%s")' where '%s' with thing as 'true' or 'false'
        @param bool  thing - the bool data to print
        @return bool  - returns the bool 'thing'

        Parameters:
         - thing
        """
        pass

    def testByte(self, thing):
        """
        Prints 'testByte("%d")' with thing as '%d'
        The types i8 and byte are synonyms, use of i8 is encouraged, byte still exists for the sake of compatibility.
        @param byte thing - the i8/byte to print
        @return i8 - returns the i8/byte 'thing'

        Parameters:
         - thing
        """
        pass

    def testI32(self, thing):
        """
        Prints 'testI32("%d")' with thing as '%d'
        @param i32 thing - the i32 to print
        @return i32 - returns the i32 'thing'

        Parameters:
         - thing
        """
        pass

    def testI64(self, thing):
        """
        Prints 'testI64("%d")' with thing as '%d'
        @param i64 thing - the i64 to print
        @return i64 - returns the i64 'thing'

        Parameters:
         - thing
        """
        pass

    def testDouble(self, thing):
        """
        Prints 'testDouble("%f")' with thing as '%f'
        @param double thing - the double to print
        @return double - returns the double 'thing'

        Parameters:
         - thing
        """
        pass

    def testBinary(self, thing):
        """
        Prints 'testBinary("%s")' where '%s' is a hex-formatted string of thing's data
        @param binary  thing - the binary data to print
        @return binary  - returns the binary 'thing'

        Parameters:
         - thing
        """
        pass

    def testStruct(self, thing):
        """
        Prints 'testStruct("{%s}")' where thing has been formatted into a string of comma separated values
        @param Xtruct thing - the Xtruct to print
        @return Xtruct - returns the Xtruct 'thing'

        Parameters:
         - thing
        """
        pass

    def testNest(self, thing):
        """
        Prints 'testNest("{%s}")' where thing has been formatted into a string of the nested struct
        @param Xtruct2 thing - the Xtruct2 to print
        @return Xtruct2 - returns the Xtruct2 'thing'

        Parameters:
         - thing
        """
        pass

    def testMap(self, thing):
        """
        Prints 'testMap("{%s")' where thing has been formatted into a string of  'key => value' pairs
         separated by commas and new lines
        @param map<i32,i32> thing - the map<i32,i32> to print
        @return map<i32,i32> - returns the map<i32,i32> 'thing'

        Parameters:
         - thing
        """
        pass

    def testStringMap(self, thing):
        """
        Prints 'testStringMap("{%s}")' where thing has been formatted into a string of  'key => value' pairs
         separated by commas and new lines
        @param map<string,string> thing - the map<string,string> to print
        @return map<string,string> - returns the map<string,string> 'thing'

        Parameters:
         - thing
        """
        pass

    def testSet(self, thing):
        """
        Prints 'testSet("{%s}")' where thing has been formatted into a string of  values
         separated by commas and new lines
        @param set<i32> thing - the set<i32> to print
        @return set<i32> - returns the set<i32> 'thing'

        Parameters:
         - thing
        """
        pass

    def testList(self, thing):
        """
        Prints 'testList("{%s}")' where thing has been formatted into a string of  values
         separated by commas and new lines
        @param list<i32> thing - the list<i32> to print
        @return list<i32> - returns the list<i32> 'thing'

        Parameters:
         - thing
        """
        pass

    def testEnum(self, thing):
        """
        Prints 'testEnum("%d")' where thing has been formatted into it's numeric value
        @param Numberz thing - the Numberz to print
        @return Numberz - returns the Numberz 'thing'

        Parameters:
         - thing
        """
        pass

    def testTypedef(self, thing):
        """
        Prints 'testTypedef("%d")' with thing as '%d'
        @param UserId thing - the UserId to print
        @return UserId - returns the UserId 'thing'

        Parameters:
         - thing
        """
        pass

    def testMapMap(self, hello):
        """
        Prints 'testMapMap("%d")' with hello as '%d'
        @param i32 hello - the i32 to print
        @return map<i32,map<i32,i32>> - returns a dictionary with these values:
          {-4 => {-4 => -4, -3 => -3, -2 => -2, -1 => -1, }, 4 => {1 => 1, 2 => 2, 3 => 3, 4 => 4, }, }

        Parameters:
         - hello
        """
        pass

    def testInsanity(self, argument):
        """
        So you think you've got this all worked, out eh?

        Creates a the returned map with these values and prints it out:
          { 1 => { 2 => argument,
                   3 => argument,
                 },
            2 => { 6 => <empty Insanity struct>, },
          }
        @return map<UserId, map<Numberz,Insanity>> - a map with the above values

        Parameters:
         - argument
        """
        pass

    def testMulti(self, arg0, arg1, arg2, arg3, arg4, arg5):
        """
        Prints 'testMulti()'
        @param i8 arg0 -
        @param i32 arg1 -
        @param i64 arg2 -
        @param map<i16, string> arg3 -
        @param Numberz arg4 -
        @param UserId arg5 -
        @return Xtruct - returns an Xtruct with string_thing = "Hello2, byte_thing = arg0, i32_thing = arg1
           and i64_thing = arg2

        Parameters:
         - arg0
         - arg1
         - arg2
         - arg3
         - arg4
         - arg5
        """
        pass

    def testException(self, arg):
        """
        Print 'testException(%s)' with arg as '%s'
        @param string arg - a string indication what type of exception to throw
        if arg == "Xception" throw Xception with errorCode = 1001 and message = arg
        elsen if arg == "TException" throw TException
        else do not throw anything

        Parameters:
         - arg
        """
        pass

    def testMultiException(self, arg0, arg1):
        """
        Print 'testMultiException(%s, %s)' with arg0 as '%s' and arg1 as '%s'
        @param string arg - a string indication what type of exception to throw
        if arg0 == "Xception" throw Xception with errorCode = 1001 and message = "This is an Xception"
        elsen if arg0 == "Xception2" throw Xception2 with errorCode = 2002 and struct_thing.string_thing = "This is an Xception2"
        else do not throw anything
        @return Xtruct - an Xtruct with string_thing = arg1

        Parameters:
         - arg0
         - arg1
        """
        pass

    def testOneway(self, secondsToSleep):
        """
        Print 'testOneway(%d): Sleeping...' with secondsToSleep as '%d'
        sleep 'secondsToSleep'
        Print 'testOneway(%d): done sleeping!' with secondsToSleep as '%d'
        @param i32 secondsToSleep - the number of seconds to sleep

        Parameters:
         - secondsToSleep
        """
        pass


class Client(Iface):
    def __init__(self, iprot, oprot=None):
        self._iprot = self._oprot = iprot
        if oprot is not None:
            self._oprot = oprot
        self._seqid = 0

    def testVoid(self):
        """
        Prints "testVoid()" and returns nothing.
        """
        self.send_testVoid()
        self.recv_testVoid()

    def send_testVoid(self):
        self._oprot.writeMessageBegin('testVoid', TMessageType.CALL, self._seqid)
        args = testVoid_args()
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_testVoid(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = testVoid_result()
        result.read(iprot)
        iprot.readMessageEnd()
        return

    def testString(self, thing):
        """
        Prints 'testString("%s")' with thing as '%s'
        @param string thing - the string to print
        @return string - returns the string 'thing'

        Parameters:
         - thing
        """
        self.send_testString(thing)
        return self.recv_testString()

    def send_testString(self, thing):
        self._oprot.writeMessageBegin('testString', TMessageType.CALL, self._seqid)
        args = testString_args()
        args.thing = thing
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_testString(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = testString_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        raise TApplicationException(TApplicationException.MISSING_RESULT, "testString failed: unknown result")

    def testBool(self, thing):
        """
        Prints 'testBool("%s")' where '%s' with thing as 'true' or 'false'
        @param bool  thing - the bool data to print
        @return bool  - returns the bool 'thing'

        Parameters:
         - thing
        """
        self.send_testBool(thing)
        return self.recv_testBool()

    def send_testBool(self, thing):
        self._oprot.writeMessageBegin('testBool', TMessageType.CALL, self._seqid)
        args = testBool_args()
        args.thing = thing
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_testBool(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = testBool_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        raise TApplicationException(TApplicationException.MISSING_RESULT, "testBool failed: unknown result")

    def testByte(self, thing):
        """
        Prints 'testByte("%d")' with thing as '%d'
        The types i8 and byte are synonyms, use of i8 is encouraged, byte still exists for the sake of compatibility.
        @param byte thing - the i8/byte to print
        @return i8 - returns the i8/byte 'thing'

        Parameters:
         - thing
        """
        self.send_testByte(thing)
        return self.recv_testByte()

    def send_testByte(self, thing):
        self._oprot.writeMessageBegin('testByte', TMessageType.CALL, self._seqid)
        args = testByte_args()
        args.thing = thing
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_testByte(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = testByte_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        raise TApplicationException(TApplicationException.MISSING_RESULT, "testByte failed: unknown result")

    def testI32(self, thing):
        """
        Prints 'testI32("%d")' with thing as '%d'
        @param i32 thing - the i32 to print
        @return i32 - returns the i32 'thing'

        Parameters:
         - thing
        """
        self.send_testI32(thing)
        return self.recv_testI32()

    def send_testI32(self, thing):
        self._oprot.writeMessageBegin('testI32', TMessageType.CALL, self._seqid)
        args = testI32_args()
        args.thing = thing
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_testI32(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = testI32_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        raise TApplicationException(TApplicationException.MISSING_RESULT, "testI32 failed: unknown result")

    def testI64(self, thing):
        """
        Prints 'testI64("%d")' with thing as '%d'
        @param i64 thing - the i64 to print
        @return i64 - returns the i64 'thing'

        Parameters:
         - thing
        """
        self.send_testI64(thing)
        return self.recv_testI64()

    def send_testI64(self, thing):
        self._oprot.writeMessageBegin('testI64', TMessageType.CALL, self._seqid)
        args = testI64_args()
        args.thing = thing
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_testI64(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = testI64_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        raise TApplicationException(TApplicationException.MISSING_RESULT, "testI64 failed: unknown result")

    def testDouble(self, thing):
        """
        Prints 'testDouble("%f")' with thing as '%f'
        @param double thing - the double to print
        @return double - returns the double 'thing'

        Parameters:
         - thing
        """
        self.send_testDouble(thing)
        return self.recv_testDouble()

    def send_testDouble(self, thing):
        self._oprot.writeMessageBegin('testDouble', TMessageType.CALL, self._seqid)
        args = testDouble_args()
        args.thing = thing
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_testDouble(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = testDouble_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        raise TApplicationException(TApplicationException.MISSING_RESULT, "testDouble failed: unknown result")

    def testBinary(self, thing):
        """
        Prints 'testBinary("%s")' where '%s' is a hex-formatted string of thing's data
        @param binary  thing - the binary data to print
        @return binary  - returns the binary 'thing'

        Parameters:
         - thing
        """
        self.send_testBinary(thing)
        return self.recv_testBinary()

    def send_testBinary(self, thing):
        self._oprot.writeMessageBegin('testBinary', TMessageType.CALL, self._seqid)
        args = testBinary_args()
        args.thing = thing
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_testBinary(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = testBinary_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        raise TApplicationException(TApplicationException.MISSING_RESULT, "testBinary failed: unknown result")

    def testStruct(self, thing):
        """
        Prints 'testStruct("{%s}")' where thing has been formatted into a string of comma separated values
        @param Xtruct thing - the Xtruct to print
        @return Xtruct - returns the Xtruct 'thing'

        Parameters:
         - thing
        """
        self.send_testStruct(thing)
        return self.recv_testStruct()

    def send_testStruct(self, thing):
        self._oprot.writeMessageBegin('testStruct', TMessageType.CALL, self._seqid)
        args = testStruct_args()
        args.thing = thing
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_testStruct(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = testStruct_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        raise TApplicationException(TApplicationException.MISSING_RESULT, "testStruct failed: unknown result")

    def testNest(self, thing):
        """
        Prints 'testNest("{%s}")' where thing has been formatted into a string of the nested struct
        @param Xtruct2 thing - the Xtruct2 to print
        @return Xtruct2 - returns the Xtruct2 'thing'

        Parameters:
         - thing
        """
        self.send_testNest(thing)
        return self.recv_testNest()

    def send_testNest(self, thing):
        self._oprot.writeMessageBegin('testNest', TMessageType.CALL, self._seqid)
        args = testNest_args()
        args.thing = thing
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_testNest(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = testNest_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        raise TApplicationException(TApplicationException.MISSING_RESULT, "testNest failed: unknown result")

    def testMap(self, thing):
        """
        Prints 'testMap("{%s")' where thing has been formatted into a string of  'key => value' pairs
         separated by commas and new lines
        @param map<i32,i32> thing - the map<i32,i32> to print
        @return map<i32,i32> - returns the map<i32,i32> 'thing'

        Parameters:
         - thing
        """
        self.send_testMap(thing)
        return self.recv_testMap()

    def send_testMap(self, thing):
        self._oprot.writeMessageBegin('testMap', TMessageType.CALL, self._seqid)
        args = testMap_args()
        args.thing = thing
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_testMap(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = testMap_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        raise TApplicationException(TApplicationException.MISSING_RESULT, "testMap failed: unknown result")

    def testStringMap(self, thing):
        """
        Prints 'testStringMap("{%s}")' where thing has been formatted into a string of  'key => value' pairs
         separated by commas and new lines
        @param map<string,string> thing - the map<string,string> to print
        @return map<string,string> - returns the map<string,string> 'thing'

        Parameters:
         - thing
        """
        self.send_testStringMap(thing)
        return self.recv_testStringMap()

    def send_testStringMap(self, thing):
        self._oprot.writeMessageBegin('testStringMap', TMessageType.CALL, self._seqid)
        args = testStringMap_args()
        args.thing = thing
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_testStringMap(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = testStringMap_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        raise TApplicationException(TApplicationException.MISSING_RESULT, "testStringMap failed: unknown result")

    def testSet(self, thing):
        """
        Prints 'testSet("{%s}")' where thing has been formatted into a string of  values
         separated by commas and new lines
        @param set<i32> thing - the set<i32> to print
        @return set<i32> - returns the set<i32> 'thing'

        Parameters:
         - thing
        """
        self.send_testSet(thing)
        return self.recv_testSet()

    def send_testSet(self, thing):
        self._oprot.writeMessageBegin('testSet', TMessageType.CALL, self._seqid)
        args = testSet_args()
        args.thing = thing
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_testSet(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = testSet_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        raise TApplicationException(TApplicationException.MISSING_RESULT, "testSet failed: unknown result")

    def testList(self, thing):
        """
        Prints 'testList("{%s}")' where thing has been formatted into a string of  values
         separated by commas and new lines
        @param list<i32> thing - the list<i32> to print
        @return list<i32> - returns the list<i32> 'thing'

        Parameters:
         - thing
        """
        self.send_testList(thing)
        return self.recv_testList()

    def send_testList(self, thing):
        self._oprot.writeMessageBegin('testList', TMessageType.CALL, self._seqid)
        args = testList_args()
        args.thing = thing
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_testList(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = testList_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        raise TApplicationException(TApplicationException.MISSING_RESULT, "testList failed: unknown result")

    def testEnum(self, thing):
        """
        Prints 'testEnum("%d")' where thing has been formatted into it's numeric value
        @param Numberz thing - the Numberz to print
        @return Numberz - returns the Numberz 'thing'

        Parameters:
         - thing
        """
        self.send_testEnum(thing)
        return self.recv_testEnum()

    def send_testEnum(self, thing):
        self._oprot.writeMessageBegin('testEnum', TMessageType.CALL, self._seqid)
        args = testEnum_args()
        args.thing = thing
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_testEnum(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = testEnum_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        raise TApplicationException(TApplicationException.MISSING_RESULT, "testEnum failed: unknown result")

    def testTypedef(self, thing):
        """
        Prints 'testTypedef("%d")' with thing as '%d'
        @param UserId thing - the UserId to print
        @return UserId - returns the UserId 'thing'

        Parameters:
         - thing
        """
        self.send_testTypedef(thing)
        return self.recv_testTypedef()

    def send_testTypedef(self, thing):
        self._oprot.writeMessageBegin('testTypedef', TMessageType.CALL, self._seqid)
        args = testTypedef_args()
        args.thing = thing
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_testTypedef(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = testTypedef_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        raise TApplicationException(TApplicationException.MISSING_RESULT, "testTypedef failed: unknown result")

    def testMapMap(self, hello):
        """
        Prints 'testMapMap("%d")' with hello as '%d'
        @param i32 hello - the i32 to print
        @return map<i32,map<i32,i32>> - returns a dictionary with these values:
          {-4 => {-4 => -4, -3 => -3, -2 => -2, -1 => -1, }, 4 => {1 => 1, 2 => 2, 3 => 3, 4 => 4, }, }

        Parameters:
         - hello
        """
        self.send_testMapMap(hello)
        return self.recv_testMapMap()

    def send_testMapMap(self, hello):
        self._oprot.writeMessageBegin('testMapMap', TMessageType.CALL, self._seqid)
        args = testMapMap_args()
        args.hello = hello
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_testMapMap(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = testMapMap_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        raise TApplicationException(TApplicationException.MISSING_RESULT, "testMapMap failed: unknown result")

    def testInsanity(self, argument):
        """
        So you think you've got this all worked, out eh?

        Creates a the returned map with these values and prints it out:
          { 1 => { 2 => argument,
                   3 => argument,
                 },
            2 => { 6 => <empty Insanity struct>, },
          }
        @return map<UserId, map<Numberz,Insanity>> - a map with the above values

        Parameters:
         - argument
        """
        self.send_testInsanity(argument)
        return self.recv_testInsanity()

    def send_testInsanity(self, argument):
        self._oprot.writeMessageBegin('testInsanity', TMessageType.CALL, self._seqid)
        args = testInsanity_args()
        args.argument = argument
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_testInsanity(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = testInsanity_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        raise TApplicationException(TApplicationException.MISSING_RESULT, "testInsanity failed: unknown result")

    def testMulti(self, arg0, arg1, arg2, arg3, arg4, arg5):
        """
        Prints 'testMulti()'
        @param i8 arg0 -
        @param i32 arg1 -
        @param i64 arg2 -
        @param map<i16, string> arg3 -
        @param Numberz arg4 -
        @param UserId arg5 -
        @return Xtruct - returns an Xtruct with string_thing = "Hello2, byte_thing = arg0, i32_thing = arg1
           and i64_thing = arg2

        Parameters:
         - arg0
         - arg1
         - arg2
         - arg3
         - arg4
         - arg5
        """
        self.send_testMulti(arg0, arg1, arg2, arg3, arg4, arg5)
        return self.recv_testMulti()

    def send_testMulti(self, arg0, arg1, arg2, arg3, arg4, arg5):
        self._oprot.writeMessageBegin('testMulti', TMessageType.CALL, self._seqid)
        args = testMulti_args()
        args.arg0 = arg0
        args.arg1 = arg1
        args.arg2 = arg2
        args.arg3 = arg3
        args.arg4 = arg4
        args.arg5 = arg5
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_testMulti(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = testMulti_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        raise TApplicationException(TApplicationException.MISSING_RESULT, "testMulti failed: unknown result")

    def testException(self, arg):
        """
        Print 'testException(%s)' with arg as '%s'
        @param string arg - a string indication what type of exception to throw
        if arg == "Xception" throw Xception with errorCode = 1001 and message = arg
        elsen if arg == "TException" throw TException
        else do not throw anything

        Parameters:
         - arg
        """
        self.send_testException(arg)
        self.recv_testException()

    def send_testException(self, arg):
        self._oprot.writeMessageBegin('testException', TMessageType.CALL, self._seqid)
        args = testException_args()
        args.arg = arg
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_testException(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = testException_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.err1 is not None:
            raise result.err1
        return

    def testMultiException(self, arg0, arg1):
        """
        Print 'testMultiException(%s, %s)' with arg0 as '%s' and arg1 as '%s'
        @param string arg - a string indication what type of exception to throw
        if arg0 == "Xception" throw Xception with errorCode = 1001 and message = "This is an Xception"
        elsen if arg0 == "Xception2" throw Xception2 with errorCode = 2002 and struct_thing.string_thing = "This is an Xception2"
        else do not throw anything
        @return Xtruct - an Xtruct with string_thing = arg1

        Parameters:
         - arg0
         - arg1
        """
        self.send_testMultiException(arg0, arg1)
        return self.recv_testMultiException()

    def send_testMultiException(self, arg0, arg1):
        self._oprot.writeMessageBegin('testMultiException', TMessageType.CALL, self._seqid)
        args = testMultiException_args()
        args.arg0 = arg0
        args.arg1 = arg1
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_testMultiException(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = testMultiException_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.err1 is not None:
            raise result.err1
        if result.err2 is not None:
            raise result.err2
        raise TApplicationException(TApplicationException.MISSING_RESULT, "testMultiException failed: unknown result")

    def testOneway(self, secondsToSleep):
        """
        Print 'testOneway(%d): Sleeping...' with secondsToSleep as '%d'
        sleep 'secondsToSleep'
        Print 'testOneway(%d): done sleeping!' with secondsToSleep as '%d'
        @param i32 secondsToSleep - the number of seconds to sleep

        Parameters:
         - secondsToSleep
        """
        self.send_testOneway(secondsToSleep)

    def send_testOneway(self, secondsToSleep):
        self._oprot.writeMessageBegin('testOneway', TMessageType.ONEWAY, self._seqid)
        args = testOneway_args()
        args.secondsToSleep = secondsToSleep
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()


class Processor(Iface, TProcessor):
    def __init__(self, handler):
        self._handler = handler
        self._processMap = {}
        self._processMap["testVoid"] = Processor.process_testVoid
        self._processMap["testString"] = Processor.process_testString
        self._processMap["testBool"] = Processor.process_testBool
        self._processMap["testByte"] = Processor.process_testByte
        self._processMap["testI32"] = Processor.process_testI32
        self._processMap["testI64"] = Processor.process_testI64
        self._processMap["testDouble"] = Processor.process_testDouble
        self._processMap["testBinary"] = Processor.process_testBinary
        self._processMap["testStruct"] = Processor.process_testStruct
        self._processMap["testNest"] = Processor.process_testNest
        self._processMap["testMap"] = Processor.process_testMap
        self._processMap["testStringMap"] = Processor.process_testStringMap
        self._processMap["testSet"] = Processor.process_testSet
        self._processMap["testList"] = Processor.process_testList
        self._processMap["testEnum"] = Processor.process_testEnum
        self._processMap["testTypedef"] = Processor.process_testTypedef
        self._processMap["testMapMap"] = Processor.process_testMapMap
        self._processMap["testInsanity"] = Processor.process_testInsanity
        self._processMap["testMulti"] = Processor.process_testMulti
        self._processMap["testException"] = Processor.process_testException
        self._processMap["testMultiException"] = Processor.process_testMultiException
        self._processMap["testOneway"] = Processor.process_testOneway

    def process(self, iprot, oprot):
        (name, type, seqid) = iprot.readMessageBegin()
        if name not in self._processMap:
            iprot.skip(TType.STRUCT)
            iprot.readMessageEnd()
            x = TApplicationException(TApplicationException.UNKNOWN_METHOD, 'Unknown function %s' % (name))
            oprot.writeMessageBegin(name, TMessageType.EXCEPTION, seqid)
            x.write(oprot)
            oprot.writeMessageEnd()
            oprot.trans.flush()
            return
        else:
            self._processMap[name](self, seqid, iprot, oprot)
        return True

    def process_testVoid(self, seqid, iprot, oprot):
        args = testVoid_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = testVoid_result()
        try:
            self._handler.testVoid()
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("testVoid", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_testString(self, seqid, iprot, oprot):
        args = testString_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = testString_result()
        try:
            result.success = self._handler.testString(args.thing)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("testString", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_testBool(self, seqid, iprot, oprot):
        args = testBool_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = testBool_result()
        try:
            result.success = self._handler.testBool(args.thing)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("testBool", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_testByte(self, seqid, iprot, oprot):
        args = testByte_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = testByte_result()
        try:
            result.success = self._handler.testByte(args.thing)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("testByte", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_testI32(self, seqid, iprot, oprot):
        args = testI32_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = testI32_result()
        try:
            result.success = self._handler.testI32(args.thing)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("testI32", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_testI64(self, seqid, iprot, oprot):
        args = testI64_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = testI64_result()
        try:
            result.success = self._handler.testI64(args.thing)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("testI64", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_testDouble(self, seqid, iprot, oprot):
        args = testDouble_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = testDouble_result()
        try:
            result.success = self._handler.testDouble(args.thing)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("testDouble", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_testBinary(self, seqid, iprot, oprot):
        args = testBinary_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = testBinary_result()
        try:
            result.success = self._handler.testBinary(args.thing)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("testBinary", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_testStruct(self, seqid, iprot, oprot):
        args = testStruct_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = testStruct_result()
        try:
            result.success = self._handler.testStruct(args.thing)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("testStruct", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_testNest(self, seqid, iprot, oprot):
        args = testNest_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = testNest_result()
        try:
            result.success = self._handler.testNest(args.thing)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("testNest", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_testMap(self, seqid, iprot, oprot):
        args = testMap_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = testMap_result()
        try:
            result.success = self._handler.testMap(args.thing)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("testMap", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_testStringMap(self, seqid, iprot, oprot):
        args = testStringMap_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = testStringMap_result()
        try:
            result.success = self._handler.testStringMap(args.thing)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("testStringMap", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_testSet(self, seqid, iprot, oprot):
        args = testSet_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = testSet_result()
        try:
            result.success = self._handler.testSet(args.thing)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("testSet", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_testList(self, seqid, iprot, oprot):
        args = testList_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = testList_result()
        try:
            result.success = self._handler.testList(args.thing)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("testList", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_testEnum(self, seqid, iprot, oprot):
        args = testEnum_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = testEnum_result()
        try:
            result.success = self._handler.testEnum(args.thing)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("testEnum", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_testTypedef(self, seqid, iprot, oprot):
        args = testTypedef_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = testTypedef_result()
        try:
            result.success = self._handler.testTypedef(args.thing)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("testTypedef", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_testMapMap(self, seqid, iprot, oprot):
        args = testMapMap_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = testMapMap_result()
        try:
            result.success = self._handler.testMapMap(args.hello)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("testMapMap", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_testInsanity(self, seqid, iprot, oprot):
        args = testInsanity_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = testInsanity_result()
        try:
            result.success = self._handler.testInsanity(args.argument)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("testInsanity", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_testMulti(self, seqid, iprot, oprot):
        args = testMulti_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = testMulti_result()
        try:
            result.success = self._handler.testMulti(args.arg0, args.arg1, args.arg2, args.arg3, args.arg4, args.arg5)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("testMulti", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_testException(self, seqid, iprot, oprot):
        args = testException_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = testException_result()
        try:
            self._handler.testException(args.arg)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except Xception as err1:
            msg_type = TMessageType.REPLY
            result.err1 = err1
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("testException", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_testMultiException(self, seqid, iprot, oprot):
        args = testMultiException_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = testMultiException_result()
        try:
            result.success = self._handler.testMultiException(args.arg0, args.arg1)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except Xception as err1:
            msg_type = TMessageType.REPLY
            result.err1 = err1
        except Xception2 as err2:
            msg_type = TMessageType.REPLY
            result.err2 = err2
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("testMultiException", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_testOneway(self, seqid, iprot, oprot):
        args = testOneway_args()
        args.read(iprot)
        iprot.readMessageEnd()
        try:
            self._handler.testOneway(args.secondsToSleep)
        except TTransport.TTransportException:
            raise
        except Exception:
            logging.exception('Exception in oneway handler')

# HELPER FUNCTIONS AND STRUCTURES


class testVoid_args:


    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('testVoid_args')
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(testVoid_args)
testVoid_args.thrift_spec = (
)


class testVoid_result:


    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('testVoid_result')
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(testVoid_result)
testVoid_result.thrift_spec = (
)


class testString_args:
    """
    Attributes:
     - thing
    """


    def __init__(self, thing=None,):
        self.thing = thing

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.thing = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('testString_args')
        if self.thing is not None:
            oprot.writeFieldBegin('thing', TType.STRING, 1)
            oprot.writeString(self.thing.encode('utf-8') if sys.version_info[0] == 2 else self.thing)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(testString_args)
testString_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'thing', 'UTF8', None, ),  # 1
)


class testString_result:
    """
    Attributes:
     - success
    """


    def __init__(self, success=None,):
        self.success = success

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRING:
                    self.success = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('testString_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.STRING, 0)
            oprot.writeString(self.success.encode('utf-8') if sys.version_info[0] == 2 else self.success)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(testString_result)
testString_result.thrift_spec = (
    (0, TType.STRING, 'success', 'UTF8', None, ),  # 0
)


class testBool_args:
    """
    Attributes:
     - thing
    """


    def __init__(self, thing=None,):
        self.thing = thing

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.BOOL:
                    self.thing = iprot.readBool()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('testBool_args')
        if self.thing is not None:
            oprot.writeFieldBegin('thing', TType.BOOL, 1)
            oprot.writeBool(self.thing)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(testBool_args)
testBool_args.thrift_spec = (
    None,  # 0
    (1, TType.BOOL, 'thing', None, None, ),  # 1
)


class testBool_result:
    """
    Attributes:
     - success
    """


    def __init__(self, success=None,):
        self.success = success

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.BOOL:
                    self.success = iprot.readBool()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('testBool_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.BOOL, 0)
            oprot.writeBool(self.success)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(testBool_result)
testBool_result.thrift_spec = (
    (0, TType.BOOL, 'success', None, None, ),  # 0
)


class testByte_args:
    """
    Attributes:
     - thing
    """


    def __init__(self, thing=None,):
        self.thing = thing

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.BYTE:
                    self.thing = iprot.readByte()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('testByte_args')
        if self.thing is not None:
            oprot.writeFieldBegin('thing', TType.BYTE, 1)
            oprot.writeByte(self.thing)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(testByte_args)
testByte_args.thrift_spec = (
    None,  # 0
    (1, TType.BYTE, 'thing', None, None, ),  # 1
)


class testByte_result:
    """
    Attributes:
     - success
    """


    def __init__(self, success=None,):
        self.success = success

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.BYTE:
                    self.success = iprot.readByte()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('testByte_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.BYTE, 0)
            oprot.writeByte(self.success)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(testByte_result)
testByte_result.thrift_spec = (
    (0, TType.BYTE, 'success', None, None, ),  # 0
)


class testI32_args:
    """
    Attributes:
     - thing
    """


    def __init__(self, thing=None,):
        self.thing = thing

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I32:
                    self.thing = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('testI32_args')
        if self.thing is not None:
            oprot.writeFieldBegin('thing', TType.I32, 1)
            oprot.writeI32(self.thing)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(testI32_args)
testI32_args.thrift_spec = (
    None,  # 0
    (1, TType.I32, 'thing', None, None, ),  # 1
)


class testI32_result:
    """
    Attributes:
     - success
    """


    def __init__(self, success=None,):
        self.success = success

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.I32:
                    self.success = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('testI32_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.I32, 0)
            oprot.writeI32(self.success)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(testI32_result)
testI32_result.thrift_spec = (
    (0, TType.I32, 'success', None, None, ),  # 0
)


class testI64_args:
    """
    Attributes:
     - thing
    """


    def __init__(self, thing=None,):
        self.thing = thing

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I64:
                    self.thing = iprot.readI64()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('testI64_args')
        if self.thing is not None:
            oprot.writeFieldBegin('thing', TType.I64, 1)
            oprot.writeI64(self.thing)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(testI64_args)
testI64_args.thrift_spec = (
    None,  # 0
    (1, TType.I64, 'thing', None, None, ),  # 1
)


class testI64_result:
    """
    Attributes:
     - success
    """


    def __init__(self, success=None,):
        self.success = success

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.I64:
                    self.success = iprot.readI64()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('testI64_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.I64, 0)
            oprot.writeI64(self.success)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(testI64_result)
testI64_result.thrift_spec = (
    (0, TType.I64, 'success', None, None, ),  # 0
)


class testDouble_args:
    """
    Attributes:
     - thing
    """


    def __init__(self, thing=None,):
        self.thing = thing

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.DOUBLE:
                    self.thing = iprot.readDouble()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('testDouble_args')
        if self.thing is not None:
            oprot.writeFieldBegin('thing', TType.DOUBLE, 1)
            oprot.writeDouble(self.thing)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(testDouble_args)
testDouble_args.thrift_spec = (
    None,  # 0
    (1, TType.DOUBLE, 'thing', None, None, ),  # 1
)


class testDouble_result:
    """
    Attributes:
     - success
    """


    def __init__(self, success=None,):
        self.success = success

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.DOUBLE:
                    self.success = iprot.readDouble()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('testDouble_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.DOUBLE, 0)
            oprot.writeDouble(self.success)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(testDouble_result)
testDouble_result.thrift_spec = (
    (0, TType.DOUBLE, 'success', None, None, ),  # 0
)


class testBinary_args:
    """
    Attributes:
     - thing
    """


    def __init__(self, thing=None,):
        self.thing = thing

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.thing = iprot.readBinary()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('testBinary_args')
        if self.thing is not None:
            oprot.writeFieldBegin('thing', TType.STRING, 1)
            oprot.writeBinary(self.thing)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(testBinary_args)
testBinary_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'thing', 'BINARY', None, ),  # 1
)


class testBinary_result:
    """
    Attributes:
     - success
    """


    def __init__(self, success=None,):
        self.success = success

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRING:
                    self.success = iprot.readBinary()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('testBinary_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.STRING, 0)
            oprot.writeBinary(self.success)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(testBinary_result)
testBinary_result.thrift_spec = (
    (0, TType.STRING, 'success', 'BINARY', None, ),  # 0
)


class testStruct_args:
    """
    Attributes:
     - thing
    """


    def __init__(self, thing=None,):
        self.thing = thing

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.thing = Xtruct()
                    self.thing.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('testStruct_args')
        if self.thing is not None:
            oprot.writeFieldBegin('thing', TType.STRUCT, 1)
            self.thing.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(testStruct_args)
testStruct_args.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'thing', [Xtruct, None], None, ),  # 1
)


class testStruct_result:
    """
    Attributes:
     - success
    """


    def __init__(self, success=None,):
        self.success = success

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRUCT:
                    self.success = Xtruct()
                    self.success.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('testStruct_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.STRUCT, 0)
            self.success.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(testStruct_result)
testStruct_result.thrift_spec = (
    (0, TType.STRUCT, 'success', [Xtruct, None], None, ),  # 0
)


class testNest_args:
    """
    Attributes:
     - thing
    """


    def __init__(self, thing=None,):
        self.thing = thing

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.thing = Xtruct2()
                    self.thing.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('testNest_args')
        if self.thing is not None:
            oprot.writeFieldBegin('thing', TType.STRUCT, 1)
            self.thing.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(testNest_args)
testNest_args.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'thing', [Xtruct2, None], None, ),  # 1
)


class testNest_result:
    """
    Attributes:
     - success
    """


    def __init__(self, success=None,):
        self.success = success

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRUCT:
                    self.success = Xtruct2()
                    self.success.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('testNest_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.STRUCT, 0)
            self.success.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(testNest_result)
testNest_result.thrift_spec = (
    (0, TType.STRUCT, 'success', [Xtruct2, None], None, ),  # 0
)


class testMap_args:
    """
    Attributes:
     - thing
    """


    def __init__(self, thing=None,):
        self.thing = thing

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.MAP:
                    self.thing = {}
                    (_ktype264, _vtype265, _size263) = iprot.readMapBegin()
                    for _i267 in range(_size263):
                        _key268 = iprot.readI32()
                        _val269 = iprot.readI32()
                        self.thing[_key268] = _val269
                    iprot.readMapEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('testMap_args')
        if self.thing is not None:
            oprot.writeFieldBegin('thing', TType.MAP, 1)
            oprot.writeMapBegin(TType.I32, TType.I32, len(self.thing))
            for kiter270, viter271 in self.thing.items():
                oprot.writeI32(kiter270)
                oprot.writeI32(viter271)
            oprot.writeMapEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(testMap_args)
testMap_args.thrift_spec = (
    None,  # 0
    (1, TType.MAP, 'thing', (TType.I32, None, TType.I32, None, False), None, ),  # 1
)


class testMap_result:
    """
    Attributes:
     - success
    """


    def __init__(self, success=None,):
        self.success = success

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.MAP:
                    self.success = {}
                    (_ktype273, _vtype274, _size272) = iprot.readMapBegin()
                    for _i276 in range(_size272):
                        _key277 = iprot.readI32()
                        _val278 = iprot.readI32()
                        self.success[_key277] = _val278
                    iprot.readMapEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('testMap_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.MAP, 0)
            oprot.writeMapBegin(TType.I32, TType.I32, len(self.success))
            for kiter279, viter280 in self.success.items():
                oprot.writeI32(kiter279)
                oprot.writeI32(viter280)
            oprot.writeMapEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(testMap_result)
testMap_result.thrift_spec = (
    (0, TType.MAP, 'success', (TType.I32, None, TType.I32, None, False), None, ),  # 0
)


class testStringMap_args:
    """
    Attributes:
     - thing
    """


    def __init__(self, thing=None,):
        self.thing = thing

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.MAP:
                    self.thing = {}
                    (_ktype282, _vtype283, _size281) = iprot.readMapBegin()
                    for _i285 in range(_size281):
                        _key286 = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                        _val287 = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                        self.thing[_key286] = _val287
                    iprot.readMapEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('testStringMap_args')
        if self.thing is not None:
            oprot.writeFieldBegin('thing', TType.MAP, 1)
            oprot.writeMapBegin(TType.STRING, TType.STRING, len(self.thing))
            for kiter288, viter289 in self.thing.items():
                oprot.writeString(kiter288.encode('utf-8') if sys.version_info[0] == 2 else kiter288)
                oprot.writeString(viter289.encode('utf-8') if sys.version_info[0] == 2 else viter289)
            oprot.writeMapEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(testStringMap_args)
testStringMap_args.thrift_spec = (
    None,  # 0
    (1, TType.MAP, 'thing', (TType.STRING, 'UTF8', TType.STRING, 'UTF8', False), None, ),  # 1
)


class testStringMap_result:
    """
    Attributes:
     - success
    """


    def __init__(self, success=None,):
        self.success = success

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.MAP:
                    self.success = {}
                    (_ktype291, _vtype292, _size290) = iprot.readMapBegin()
                    for _i294 in range(_size290):
                        _key295 = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                        _val296 = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                        self.success[_key295] = _val296
                    iprot.readMapEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('testStringMap_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.MAP, 0)
            oprot.writeMapBegin(TType.STRING, TType.STRING, len(self.success))
            for kiter297, viter298 in self.success.items():
                oprot.writeString(kiter297.encode('utf-8') if sys.version_info[0] == 2 else kiter297)
                oprot.writeString(viter298.encode('utf-8') if sys.version_info[0] == 2 else viter298)
            oprot.writeMapEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(testStringMap_result)
testStringMap_result.thrift_spec = (
    (0, TType.MAP, 'success', (TType.STRING, 'UTF8', TType.STRING, 'UTF8', False), None, ),  # 0
)


class testSet_args:
    """
    Attributes:
     - thing
    """


    def __init__(self, thing=None,):
        self.thing = thing

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.SET:
                    self.thing = set()
                    (_etype302, _size299) = iprot.readSetBegin()
                    for _i303 in range(_size299):
                        _elem304 = iprot.readI32()
                        self.thing.add(_elem304)
                    iprot.readSetEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('testSet_args')
        if self.thing is not None:
            oprot.writeFieldBegin('thing', TType.SET, 1)
            oprot.writeSetBegin(TType.I32, len(self.thing))
            for iter305 in self.thing:
                oprot.writeI32(iter305)
            oprot.writeSetEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(testSet_args)
testSet_args.thrift_spec = (
    None,  # 0
    (1, TType.SET, 'thing', (TType.I32, None, False), None, ),  # 1
)


class testSet_result:
    """
    Attributes:
     - success
    """


    def __init__(self, success=None,):
        self.success = success

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.SET:
                    self.success = set()
                    (_etype309, _size306) = iprot.readSetBegin()
                    for _i310 in range(_size306):
                        _elem311 = iprot.readI32()
                        self.success.add(_elem311)
                    iprot.readSetEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('testSet_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.SET, 0)
            oprot.writeSetBegin(TType.I32, len(self.success))
            for iter312 in self.success:
                oprot.writeI32(iter312)
            oprot.writeSetEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(testSet_result)
testSet_result.thrift_spec = (
    (0, TType.SET, 'success', (TType.I32, None, False), None, ),  # 0
)


class testList_args:
    """
    Attributes:
     - thing
    """


    def __init__(self, thing=None,):
        self.thing = thing

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.LIST:
                    self.thing = []
                    (_etype316, _size313) = iprot.readListBegin()
                    for _i317 in range(_size313):
                        _elem318 = iprot.readI32()
                        self.thing.append(_elem318)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('testList_args')
        if self.thing is not None:
            oprot.writeFieldBegin('thing', TType.LIST, 1)
            oprot.writeListBegin(TType.I32, len(self.thing))
            for iter319 in self.thing:
                oprot.writeI32(iter319)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(testList_args)
testList_args.thrift_spec = (
    None,  # 0
    (1, TType.LIST, 'thing', (TType.I32, None, False), None, ),  # 1
)


class testList_result:
    """
    Attributes:
     - success
    """


    def __init__(self, success=None,):
        self.success = success

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.LIST:
                    self.success = []
                    (_etype323, _size320) = iprot.readListBegin()
                    for _i324 in range(_size320):
                        _elem325 = iprot.readI32()
                        self.success.append(_elem325)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('testList_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.LIST, 0)
            oprot.writeListBegin(TType.I32, len(self.success))
            for iter326 in self.success:
                oprot.writeI32(iter326)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(testList_result)
testList_result.thrift_spec = (
    (0, TType.LIST, 'success', (TType.I32, None, False), None, ),  # 0
)


class testEnum_args:
    """
    Attributes:
     - thing
    """


    def __init__(self, thing=None,):
        self.thing = thing

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I32:
                    self.thing = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('testEnum_args')
        if self.thing is not None:
            oprot.writeFieldBegin('thing', TType.I32, 1)
            oprot.writeI32(self.thing)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(testEnum_args)
testEnum_args.thrift_spec = (
    None,  # 0
    (1, TType.I32, 'thing', None, None, ),  # 1
)


class testEnum_result:
    """
    Attributes:
     - success
    """


    def __init__(self, success=None,):
        self.success = success

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.I32:
                    self.success = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('testEnum_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.I32, 0)
            oprot.writeI32(self.success)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(testEnum_result)
testEnum_result.thrift_spec = (
    (0, TType.I32, 'success', None, None, ),  # 0
)


class testTypedef_args:
    """
    Attributes:
     - thing
    """


    def __init__(self, thing=None,):
        self.thing = thing

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I64:
                    self.thing = iprot.readI64()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('testTypedef_args')
        if self.thing is not None:
            oprot.writeFieldBegin('thing', TType.I64, 1)
            oprot.writeI64(self.thing)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(testTypedef_args)
testTypedef_args.thrift_spec = (
    None,  # 0
    (1, TType.I64, 'thing', None, None, ),  # 1
)


class testTypedef_result:
    """
    Attributes:
     - success
    """


    def __init__(self, success=None,):
        self.success = success

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.I64:
                    self.success = iprot.readI64()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('testTypedef_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.I64, 0)
            oprot.writeI64(self.success)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(testTypedef_result)
testTypedef_result.thrift_spec = (
    (0, TType.I64, 'success', None, None, ),  # 0
)


class testMapMap_args:
    """
    Attributes:
     - hello
    """


    def __init__(self, hello=None,):
        self.hello = hello

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I32:
                    self.hello = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('testMapMap_args')
        if self.hello is not None:
            oprot.writeFieldBegin('hello', TType.I32, 1)
            oprot.writeI32(self.hello)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(testMapMap_args)
testMapMap_args.thrift_spec = (
    None,  # 0
    (1, TType.I32, 'hello', None, None, ),  # 1
)


class testMapMap_result:
    """
    Attributes:
     - success
    """


    def __init__(self, success=None,):
        self.success = success

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.MAP:
                    self.success = {}
                    (_ktype328, _vtype329, _size327) = iprot.readMapBegin()
                    for _i331 in range(_size327):
                        _key332 = iprot.readI32()
                        _val333 = {}
                        (_ktype335, _vtype336, _size334) = iprot.readMapBegin()
                        for _i338 in range(_size334):
                            _key339 = iprot.readI32()
                            _val340 = iprot.readI32()
                            _val333[_key339] = _val340
                        iprot.readMapEnd()
                        self.success[_key332] = _val333
                    iprot.readMapEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('testMapMap_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.MAP, 0)
            oprot.writeMapBegin(TType.I32, TType.MAP, len(self.success))
            for kiter341, viter342 in self.success.items():
                oprot.writeI32(kiter341)
                oprot.writeMapBegin(TType.I32, TType.I32, len(viter342))
                for kiter343, viter344 in viter342.items():
                    oprot.writeI32(kiter343)
                    oprot.writeI32(viter344)
                oprot.writeMapEnd()
            oprot.writeMapEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(testMapMap_result)
testMapMap_result.thrift_spec = (
    (0, TType.MAP, 'success', (TType.I32, None, TType.MAP, (TType.I32, None, TType.I32, None, False), False), None, ),  # 0
)


class testInsanity_args:
    """
    Attributes:
     - argument
    """


    def __init__(self, argument=None,):
        self.argument = argument

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.argument = Insanity.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('testInsanity_args')
        if self.argument is not None:
            oprot.writeFieldBegin('argument', TType.STRUCT, 1)
            self.argument.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(testInsanity_args)
testInsanity_args.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'argument', [Insanity, None], None, ),  # 1
)


class testInsanity_result:
    """
    Attributes:
     - success
    """


    def __init__(self, success=None,):
        self.success = success

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.MAP:
                    self.success = {}
                    (_ktype346, _vtype347, _size345) = iprot.readMapBegin()
                    for _i349 in range(_size345):
                        _key350 = iprot.readI64()
                        _val351 = {}
                        (_ktype353, _vtype354, _size352) = iprot.readMapBegin()
                        for _i356 in range(_size352):
                            _key357 = iprot.readI32()
                            _val358 = Insanity.read(iprot)
                            _val351[_key357] = _val358
                        iprot.readMapEnd()
                        self.success[_key350] = _val351
                    iprot.readMapEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('testInsanity_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.MAP, 0)
            oprot.writeMapBegin(TType.I64, TType.MAP, len(self.success))
            for kiter359, viter360 in self.success.items():
                oprot.writeI64(kiter359)
                oprot.writeMapBegin(TType.I32, TType.STRUCT, len(viter360))
                for kiter361, viter362 in viter360.items():
                    oprot.writeI32(kiter361)
                    viter362.write(oprot)
                oprot.writeMapEnd()
            oprot.writeMapEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(testInsanity_result)
testInsanity_result.thrift_spec = (
    (0, TType.MAP, 'success', (TType.I64, None, TType.MAP, (TType.I32, None, TType.STRUCT, [Insanity, None], False), False), None, ),  # 0
)


class testMulti_args:
    """
    Attributes:
     - arg0
     - arg1
     - arg2
     - arg3
     - arg4
     - arg5
    """


    def __init__(self, arg0=None, arg1=None, arg2=None, arg3=None, arg4=None, arg5=None,):
        self.arg0 = arg0
        self.arg1 = arg1
        self.arg2 = arg2
        self.arg3 = arg3
        self.arg4 = arg4
        self.arg5 = arg5

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.BYTE:
                    self.arg0 = iprot.readByte()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.I32:
                    self.arg1 = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.I64:
                    self.arg2 = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.MAP:
                    self.arg3 = {}
                    (_ktype364, _vtype365, _size363) = iprot.readMapBegin()
                    for _i367 in range(_size363):
                        _key368 = iprot.readI16()
                        _val369 = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                        self.arg3[_key368] = _val369
                    iprot.readMapEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.I32:
                    self.arg4 = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 6:
                if ftype == TType.I64:
                    self.arg5 = iprot.readI64()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('testMulti_args')
        if self.arg0 is not None:
            oprot.writeFieldBegin('arg0', TType.BYTE, 1)
            oprot.writeByte(self.arg0)
            oprot.writeFieldEnd()
        if self.arg1 is not None:
            oprot.writeFieldBegin('arg1', TType.I32, 2)
            oprot.writeI32(self.arg1)
            oprot.writeFieldEnd()
        if self.arg2 is not None:
            oprot.writeFieldBegin('arg2', TType.I64, 3)
            oprot.writeI64(self.arg2)
            oprot.writeFieldEnd()
        if self.arg3 is not None:
            oprot.writeFieldBegin('arg3', TType.MAP, 4)
            oprot.writeMapBegin(TType.I16, TType.STRING, len(self.arg3))
            for kiter370, viter371 in self.arg3.items():
                oprot.writeI16(kiter370)
                oprot.writeString(viter371.encode('utf-8') if sys.version_info[0] == 2 else viter371)
            oprot.writeMapEnd()
            oprot.writeFieldEnd()
        if self.arg4 is not None:
            oprot.writeFieldBegin('arg4', TType.I32, 5)
            oprot.writeI32(self.arg4)
            oprot.writeFieldEnd()
        if self.arg5 is not None:
            oprot.writeFieldBegin('arg5', TType.I64, 6)
            oprot.writeI64(self.arg5)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(testMulti_args)
testMulti_args.thrift_spec = (
    None,  # 0
    (1, TType.BYTE, 'arg0', None, None, ),  # 1
    (2, TType.I32, 'arg1', None, None, ),  # 2
    (3, TType.I64, 'arg2', None, None, ),  # 3
    (4, TType.MAP, 'arg3', (TType.I16, None, TType.STRING, 'UTF8', False), None, ),  # 4
    (5, TType.I32, 'arg4', None, None, ),  # 5
    (6, TType.I64, 'arg5', None, None, ),  # 6
)


class testMulti_result:
    """
    Attributes:
     - success
    """


    def __init__(self, success=None,):
        self.success = success

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRUCT:
                    self.success = Xtruct()
                    self.success.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('testMulti_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.STRUCT, 0)
            self.success.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(testMulti_result)
testMulti_result.thrift_spec = (
    (0, TType.STRUCT, 'success', [Xtruct, None], None, ),  # 0
)


class testException_args:
    """
    Attributes:
     - arg
    """


    def __init__(self, arg=None,):
        self.arg = arg

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.arg = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('testException_args')
        if self.arg is not None:
            oprot.writeFieldBegin('arg', TType.STRING, 1)
            oprot.writeString(self.arg.encode('utf-8') if sys.version_info[0] == 2 else self.arg)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(testException_args)
testException_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'arg', 'UTF8', None, ),  # 1
)


class testException_result:
    """
    Attributes:
     - err1
    """


    def __init__(self, err1=None,):
        self.err1 = err1

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.err1 = Xception()
                    self.err1.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('testException_result')
        if self.err1 is not None:
            oprot.writeFieldBegin('err1', TType.STRUCT, 1)
            self.err1.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(testException_result)
testException_result.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'err1', [Xception, None], None, ),  # 1
)


class testMultiException_args:
    """
    Attributes:
     - arg0
     - arg1
    """


    def __init__(self, arg0=None, arg1=None,):
        self.arg0 = arg0
        self.arg1 = arg1

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.arg0 = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.arg1 = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('testMultiException_args')
        if self.arg0 is not None:
            oprot.writeFieldBegin('arg0', TType.STRING, 1)
            oprot.writeString(self.arg0.encode('utf-8') if sys.version_info[0] == 2 else self.arg0)
            oprot.writeFieldEnd()
        if self.arg1 is not None:
            oprot.writeFieldBegin('arg1', TType.STRING, 2)
            oprot.writeString(self.arg1.encode('utf-8') if sys.version_info[0] == 2 else self.arg1)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(testMultiException_args)
testMultiException_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'arg0', 'UTF8', None, ),  # 1
    (2, TType.STRING, 'arg1', 'UTF8', None, ),  # 2
)


class testMultiException_result:
    """
    Attributes:
     - success
     - err1
     - err2
    """


    def __init__(self, success=None, err1=None, err2=None,):
        self.success = success
        self.err1 = err1
        self.err2 = err2

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRUCT:
                    self.success = Xtruct()
                    self.success.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.err1 = Xception()
                    self.err1.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.err2 = Xception2()
                    self.err2.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('testMultiException_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.STRUCT, 0)
            self.success.write(oprot)
            oprot.writeFieldEnd()
        if self.err1 is not None:
            oprot.writeFieldBegin('err1', TType.STRUCT, 1)
            self.err1.write(oprot)
            oprot.writeFieldEnd()
        if self.err2 is not None:
            oprot.writeFieldBegin('err2', TType.STRUCT, 2)
            self.err2.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(testMultiException_result)
testMultiException_result.thrift_spec = (
    (0, TType.STRUCT, 'success', [Xtruct, None], None, ),  # 0
    (1, TType.STRUCT, 'err1', [Xception, None], None, ),  # 1
    (2, TType.STRUCT, 'err2', [Xception2, None], None, ),  # 2
)


class testOneway_args:
    """
    Attributes:
     - secondsToSleep
    """


    def __init__(self, secondsToSleep=None,):
        self.secondsToSleep = secondsToSleep

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I32:
                    self.secondsToSleep = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('testOneway_args')
        if self.secondsToSleep is not None:
            oprot.writeFieldBegin('secondsToSleep', TType.I32, 1)
            oprot.writeI32(self.secondsToSleep)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(testOneway_args)
testOneway_args.thrift_spec = (
    None,  # 0
    (1, TType.I32, 'secondsToSleep', None, None, ),  # 1
)
fix_spec(all_structs)
del all_structs

